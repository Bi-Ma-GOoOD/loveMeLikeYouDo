# :zap: TICKING AWAY !!! :zap:

## :trophy: F-I-N-A-L :sparkles:

> :link: Subject That you can see how we so far ^.^
> * :book: [Computer Architecture](#computer-architecture-floppy_disk) :pencil2:
> * :headphones: [Software Construction Lecture](#software-construction-lecture-hotsprings) :notes:
> * :guitar: [Data Structure](#data-structure-open_file_folder) :microphone:

### :stars: SEASON OF MIND :snowflake:
![This is picture.](/Images/Inspiration_n_love/GODS.jpg "GODS!!!!!")

### :clubs: MY WORK :spades:
* My-Work :beginner: [Start Here](Art-Work/My_Beginner_work/) :performing_arts:

### Computer Architecture :floppy_disk:
> * :sunrise_over_mountains: [IF I CAN DREAM](#zap-ticking-away--zap) :sunrise:
><br>แนวข้อสอบปลายภาคแล้วนะะะ สู้ๆ
><br>:question: แนวคำถามเหมือนเดิมเลย: คืออะไร ทำหน้าที่อะไร ทำงานอย่างไร มีอะไรบ้าง มีความสัมพันธ์กันอย่างไร :question:
><br>ประมาณ 10 หัวข้อ จากหัวข้อต่อไปนี้:
>- กลไกการป้องกันหน่วยความจำ (Memory Protection Mechanisms) :heavy_check_mark:
>- หน่วยความจำเสมือน (Virtual Memory) :heavy_check_mark:
>- ตัวควบคุมอุปกรณ์นำเข้าและส่งออก (I/O Controllers) :heavy_check_mark:
>- การกำหนดที่อยู่ของอุปกรณ์นำเข้าและส่งออก (Input/Output Address Space) :heavy_check_mark:
>- ขั้นตอนการทำงานของคำสั่ง (Instruction Execution Stages) :heavy_check_mark:
>- การประมวลผลแบบเป็นลำดับและแบบไปป์ไลน์ (Sequential and Pipelined Execution) :heavy_check_mark:
>- อันตรายของการทำงานแบบไปป์ไลน์ (Pipeline Hazards) :heavy_check_mark:
>- ประเภทของมัลติโพรเซสซิง (Types of Multiprocessing) :heavy_check_mark:
>- ประเภทของการทำงานแบบขนาน (Parallelism) :heavy_check_mark:
>- สถาปัตยกรรมของหน่วยความจำ (Memory Architectures) :heavy_check_mark:
>- ประเภทของการเชื่อมต่อ (Types of Interconnects) :heavy_check_mark:
>- ประเภทของการทำงานแบบหลายเธรด (Types of Multithreading) :heavy_check_mark:
>- กลไกที่ทำให้หน่วยความจำตรงกัน (Memory Synchronization Mechanisms) :heavy_check_mark:
>- โมเดลความสม่ำเสมอของหน่วยความจำ (Memory Consistency Models) :heavy_check_mark:
>- โปรโตคอลความเชื่อมโยงกันของหน่วยความจำ (Memory Coherence Protocols) :heavy_check_mark:
>- ตัววัดประสิทธิภาพ (Performance Metrics) :heavy_check_mark:
>- สิ่งที่ต้องแลกมาเพื่อประสิทธิภาพ (Performance Trade-offs) :heavy_check_mark:

* Read 11st chapters in slide **11-Memory Protection** finished 09:54 On 19/10/2023 :alien:
    ```
    คือในบทนี้อะ เราจะกล่าวเกี่ยวกับ สิทธิ์และการเข้าถึงพื้นที่ในหน่วยความจำของแต่ละ Process แบบที่ควรจะเป็นอะ ซึ่งแบ่งได้ ดังนี้
    <--> Privilege Levels : อันนี้เขาจะอธิบายเกี่ยวกับสิทธิ์ในการเข้าถึงแบบทุกเรื่องเลย ไม่ใช่แค่หน่วยความจำอย่างเดียว
            - User Mode : สิทธิ์ในการเข้าถึงน้อยสุดเลยยค่า แต่ โปรแกรมที่เราใช้ รวมถึงตัวเราด้วย ก็อยู่ใน Mode นี้นะ
            - Kernel Mode(Supervisor Mode) : โหมดนี้แม่งคือ GODS อะแบบเข้าถึงได้ทุกอย่างเพราะเขาต้องคอยจัดการเรื่องทุกๆอย่างเลยแทนเรา อีกอย่างโหมดนี้จะเป็น โหมดที่จะคอยสื่อสาร Hardware แทนเราด้วยนะ เพราะเราทำเองไม่ได้ เขาต้องทำให้ คือจริง Kernel ก็คือ OS นี่แหละ
    <--> Memory Protection Unit(MPU) : หน่วยนี้คือการเช็คว่า ข้อมูลที่ CPU ร้องขอมาเนี่ยมันถูกจริงๆใช่ไหม เพราะเวลาปกติ CPU เขาร้องขอข้อมูลด้วยการส่งที่อยู่มาอะ ตัว MPU นี่แหละจะเช็คว่า จริงอ่ะป่าววว ซึ่งตัว MPU จะเช็คได้ ก็เกิดจาก Kernel เช่นกัน
            - Segment Register : สิ่งนี้คือ หน่วยความจำที่อยู่ใน MPU ที่จะคอยเก็บช่วงของตำแหน่งของ Process นั่นๆ เลย ซึ่งแบ่งได้ 4 ส่วน พวก ES อะไรก็ว่าไป
    <--> Address Space Layout Randomization(ASLR) : หัวข้อสูดท้ายยแย้ววว อันนี้คือ การสุ่มลำดับที่อยู่ ที่คอยจัดเก็บข้อมูลคับ แค่นั้นเลย โดยใช้ Padding 
            - Padding : คือหน่วยความจำว่างเปล่า ที่จะคอยแทรกระหว่าง section ตำแหน่งของข้อมูลต่างๆ ทำให้เกิดการคาดเดาได้ยากอะ ว่าข้อมูลนี้อยู่ที่ไหน
    ```
* Read 12nd chapters in slide **12-Memory Translation** finished 10:51 On 19/10/2023 :recycle:
    ```
    ในบทนี้อะเราจะกล่าวเกี่ยวกับการจัดเก็บข้อมูล แต่มันจัดเก็บข้อมูลแบบเสมือนนั่นก็คือ
    <--> Virtual Memory : นี่เป็นเหตุผลที่ว่า ทำไมเวลาคอมเราใช้ Ram 100 % ง่ะ จอถึงไม่ฟ้า เพราะว่าการจัดเก็บข้อมูลประเภทนี้ คือ การเก็บข้อมูลแบบเสมือนนั่นเอง ซึ่งสิ่งที่ CPU ร้องขอข้อมูลจากบทที่แล้วอะ ที่ส่งตำแหน่งมาอะ CPU ก็ส่งที่อยู่เสมือนมา และสุดท้ายก็ต้องมีการแปลง เป็นที่อยู่จริง(Physical Memory) ซึ่งขั้นตอนกลางแปลงเนี่ยจะแบ่งได้ตามนี้
            - Pages and Frames : ทั้งคู่ คือ หน่วยเก็บข้อมูลย่อยของ Virtual and Physical ตามลำดับ ซึ่งทั้งสองนี้จะมีขนาดข้อมูลที่เท่ากันนะ ซึ่ง frames อะเปรียบเสมือน Memory Block เลย แบบเก็บเป็น Block เลยอะ ใน เฟรมๆ เดียว
            - Page Tables : คือตัวแปลงจาก Virtual->Physical งับ ซึ่ง 1 Process : 1 - - Page Table
            - Page Tables Entries(PTEs) : สิ่งนี้จะอยู่ใน Page Tables และสิ่งนี้แหละที่คอยเก็บว่า page เลขที่เท่านี้จะถูกเก็บไว้ใน Frame ไหน เพราะ PTEs เขาเก็บเลข Frame เอาไว้
            - Translation Lookaside Buffer(TLB) : อันนี้อยู่ใน PTEs อีกทีงับ อันนี้เขาจะมีหน้าที่แบบว่า ช่วยให้ตัวของ Page Table เนี่ยแปลงไวขึ้น แบบว่าจะมึทั้ง TLB Hit และ TLB Miss เลย คล้ายๆ Cache
            - Memory Management Units(MMUs) : อันนี้คือตัวสุดท้ายที่แบบว่า คอยทำทุกอย่างเลย เป็นตัวตรงกลางที่อยู่ระหว่าง CPU และ Address Bus คือ 4 หัวข้อที่กล่าวมาข้างบนอะ ถูกตัวนี้แหละ ที่ทั้งแปลง และเช็คอะไรต่างๆ ตัวนี้เป็น Hardware นะงับ
    ```
* Read 13rd chapters in slide **13-IO System** finished 15:57 On 19/10/2023 :fire:
    ```
    คือบทนี้อะงับเราจะพูดเกี่ยวกับตัวของ Input/Output System ซึ่งแบ่งได้หลักๆ ตามนี้
    <--> I/O Controller : ตัวนี้จะเป็นตัวกลางที่อยู่ระหว่าง CPU และ Devices คอยเชื่อมเข้าหากัน แบบไม่ต้องให้ CPU เหนื่อย ซึ่งตัวของ I/O Controllers อะไม่จำเป็นที่จะต้องมี 1 Devices : 1 Controller นะ คือ 1 Controller อะ อาจจะควบคุมหลายอุปกรณ์ก็ได้แล้วแต่เยย ซึ่งจะมีส่วนประกอบทั้งหมด 5 ส่วน ได้แก่
            - Address Decoder : จะเป็นตัวถอดรหัสของตัว Device กับ ที่อยู่ของ CPU ที่ส่งมาว่า ที่อยู่นี้อะที่ส่งมาอะ คุณกดปุ่มอะไรคุณบอกผมสิ อะไรประมาณนี้
            - Control Unit : ส่วนนี้ง่ายๆนะ มันคือ ส่วนควบคุมของ Device เลย ซึ่่งบางที่อาจจะไปควบคุม ส่วนอื่นๆด้วย ถ้าหาก Device นี้มีการเข้าถึงข้อมูลส่วนอื่นๆ
            - Control Register : ตัวนี้เอาไว้คอยเก็บคำสั่งงับ
            - Status Register : ตัวนี้เอาไว้เช็คว่า เออ Device นี้ยังทำงานปกติอยู่อ่ะป่าววฮื่อ
            - Data Register : อันนี้คือ การเก็บข้อมูลของ Device งับ เช่น ผู้ใช้งานกดปุ่ม คีย์บอดร์ ตัว Data นี่แหละที่เก็บข้อมูลไว้ว่า ผู้ใช้กดปุ่มไรบ้าง
    --> I/O Interface : อันนี้คือ ง่ายๆเลยนะงับ น้องคือ port ที่อยู่ระหว่างการเชื่อมของ Device และ I/O Controller ซึ่งแบ่งได้ 2 ประเภทงับ ได้แก่
            - Serial Interface : คือการส่งข้อมูล 1 bit : 1 cycle ช้าแต่ไม่ค่อยมีข้อผิดพลาด
            - Parallel Interface : คือการส่งข้อมูล หลาย bits : 1 cycle เร็วแต่อาจจะมีข้อผิดพลาด เพราะในช่วงเวลาเดียวกัน มีการส่งข้อมูลหลาย bits
    <--> I/O Address Space : การเก็บข้อมูลของ I/O แบ่งได้ 2 รูปแบบงับ งือ
            - Memory Mapped : คือ ตัวที่อยู่ของ I/O อะใช้พื้นที่รวมกันเลยไม่ได้มีการแบ่ง แบบว่าตัวของ I/O อะเขาอยู่ในช่วงที่หน่วยความจำจัดไว้ให้แล้ว ข้อดีคือ เข้าถึงข้อมูลได้ง่าย แต่มีความปลอดภัยต่ำ
            - Isolated : ส่วนอันนี้ง่ะ คือ ตัวที่ของ I/O กับ ที่อยู่ของหน่วยความจำอะ แยกกันเก็บเลย เพราะฉะนั้นข้อดีคือ มีความปลอดภัยสูงเพราะแยกกันเก็บ แต่ข้อเสียคือ ต้องมีคำสั่งพิเศษในการเข้าถึงข้อมูล เพราะถ้าหากมี Address ที่ต้องการเข้าถึงอะ ที่อยู่เลขเดียวกันเลย แต่เราต้องการเข้าถึง ที่อยู่ของ 
            I/O อะ เราก็ต้องมีคำสั่งพิเศษ เพื่อป้องกันเอาไว้
        
    ```
* Read 14th chapters in slide **14-Pipelinning** finished 22:59 On 19/10/2023 :ramen:
    ```
    ในบทนี้เราจะกล่าวเกี่ยวกัว การรัน รันยังไงไปดู
    <--> Instruction Execute Stages : คือขั้นตอนของการทำ Cycle ซึ่งแบ่งได้ 4 แต่ว่าเราจะเขียนไป 5 เลย ก็คือ
            - Ins Fetch(IF) : การนำข้อมูลจาก Ram ไปใส่ไว้ใน IR(Instruction Register)
            - Ins Decode(ID) : การถอดรหัสของคำสั่ง ซึ่งการถอดรหัสนี้ถูกกระทำโดย Control Unit
            - Op Fetch(OF) : หลังจากการถอดคำสั่งแล้วอะ บางทีเราต้องการค่าจากที่อื่นด้วยก่อน ประมวลผลฉะนั้นเลยมีขั้นตอนนี้นี่แล
            - Ins Execute(IE) : ขั้นตอนนี้การประมวลผลเลยงับ แล้วเอาค่าไปใส่ไว้ใน Register
            - Op Store(OP) : การเก็บผลลัพธ์ที่ได้จากการประมวลผลงับ
    <--> Instruction Execution : อันนี้อะ คือขั้นตอนของการกระทำการประมวลผล ซึ่งจะมี 2 รูปแบบได้แก่
            - Sequantial Exe : คือการรัน 1 คำสั่งให้เสร็จ พอเสร็จแล้วคำสั่งต่อไปค่อยทำงาน ซึ่งถ้าหากใน 1 คำสั่งมี 5 ขั้นตอนก็รอให้ทำแต่ละขั้นตอนจนเสร็จอะ ซึ่งวิธีนี้ไม่ค่อยดีนะ มันจะนำไปสู่การใช้ทรัพยากรที่ไม่คุ้มค่า Underutilization
            - Piplined Exe : ส่วนอันนี้ แนวคิดเขาคือว่า เอ๊ะ ถ้าหากว่า ในช่วงที่ process กำลังประมวลผลอยู่อะ แปลว่า Instruction ที่เป็นในส่วนของ Fetch Decode อะไรพวกนี้อะ ก็ว่างอะดิ ฉะนั้นแนวคิดก็คือ ถ้าหากว่า Instruction ที่ว่างอะให้ทำงานต่อเลย จึงทำให้เกิดการใช้ทรัพยากรอย่างคุ้มค่านั่นเองงับ
    ```
* Read 15th chapters in slide **15-Pipeline Hazards** finished 21:18 On 20/10/2023 :exclamation:
    ```
    คือบทนี้อะเราจะกล่าวเกี่ยวกับ ข้อผิดพลาดหรือว่าอันตรายที่เกิดจากการใช้ Exe แบบ Pipline ซึ่งข้อเสียจะแบ่งได้ 3 ประเภทใหญ่ๆ ได้แก่
        <-> Structual Hazard : อันนี้น้องจะบอกประมาณว่า เออถ้าแบบใน Ins Stages อะเราบอกว่า ถ้าว่างให้ทำต่อไปเลอใช่ม่ะ แล้วถ้าหากว่า Ins Stages มีการเข้าถึงข้อมูลพร้อมกันอะ เราจะต้องมีการรอก่อนนะ เพราะไม่งั้นมันจะเกิด error 
        <-> Data Hazard : อันนี้ก็เหมือนกันครับมันประมาณว่า ในขั้นตอนการรันอะ แล้วถ้าคำสั่งนั้นต้องการ ผลลัพธ์จากคำสั่งอันอื่นอะ แล้วพอดีว่าคำสั่งนั้นยังไม่เสร็จอะ เท่ากับว่า ระบบก็ต้องรอเหมือนกันฮ่าๆ เพื่อป้องกันการเกิด error
        ซึ่งการรอของ Hazard ทั้งคู่เนี่ย จะมีการใช้คำว่า Stall, Idles และ Bubbles การรอ คือ การรอให้ Stages นั้นจบลงไปก่อนแล้วตัวเองค่อยทำต่อ
        <-> Control Hazard : อันนี้จะงงๆ หน่อยนะแต่เนื้อหาหลักๆ คือ ตัวของ Pipeline อะเขารันตลอดเวลา พอแบบเวลาเจอ if-else อะ เขาจะก็รันคำสั่งใน if รอเลย แต่!!
        ถ้าหากว่าคำสั่งใน if มันไม่ต้องใช้เพราะว่านิพจน์เป็นเท็จอะ ตัว pipeline ก็ต้องไปรันคำสั่งใน else ต่อซึ่งทำให้คำสั่งที่ทำก่อนหน้านี้ที่ทำกับ if กลายเป็นเสียเปล่า ซึ่งวิธีแก้ก็อาจจะแบบ ใช้การ Predict หรือการ ข้ามคำสั่งที่เกี่ยวกับ if-else loop อะไรพวกนี้ไปก่อน
    ```
* Read 16th chapters in slide **16-Multiprocessing** finished 10:46 On 21/10/2023 :speech_balloon:
    ```
    คือในบทนี้ออะ เราจะพูดเกี่ยวกับการทำงานแบบ Multiprocessing หรือว่า Multicore อยู่ที่การเพิ่ม Hardware ว่าเพิ่มอะไรถ้าเพิ่ม Processor ก็เรียกแบบอันแรก ถ้าเพิ่ม Core ก็เรียกแบบอันหลัง ซึ่งตัวของ Multiprocessing อะจะประกอบไปด้วย
        - CPU : คือตัวประมวลคำสั่งและเป็นตัวให้โปรแกรมทำงานเลย
        - Processor : อันนี้อะคือ ตัวชิปที่เอาไว้ใส่กับ Mainboard อะงับ ซึ่งในนี้ก็จะมี Register Cache อะไรก็ว่าไป
        - Core : อันนี้คือส่วนคำนวณหลักเลยงับ เพราะว่า ในนี้มี ALU และ Control Unit เป็นส่วนประกอบหลักๆ
        - Thread : คือหน่วยการทำงานของ process งับ แบบว่า 1 prog : 1 process : 1 thread
        ซึ่งในทนี้เราจะมาเน้นนอกจากเนื้อหาข้างบนที่กล่าวไปแล้ว ยังมีอีก 2 อย่าง คือ
  <--> Types of Multiprocessing อันนี้อะแบ่งได้ 2 ประเภท คือ
        - Symmetric : อันนี้อะงับ คือการที่แบบว่า เราต้องการจะทำ Multiprocessing ชิมิ ซึ่งการทำ Multi ง่ะ มันต้องเพิ่ม Hardware ซึ่งถ้าหากว่าเราเพิ่ม Hardware ชนิดเดียวกันอะงับ เราจะเรียกว่า สมมาตร(Symmetric) เพราะทั้งการทำงานและผลลัพธ์ที่ได้จะเหมือนกันเลย
        - Asymmetric : แต่อันนี้อะงับต่อให้เราเพิ่ม Hardware ประเภทเดียวกันง่ะ ผลลัพธ์ที่ได้จะต่างกัน รวมถึงการทำงานก็ต่างกันด้วย
  <--> Types of Interconnects : หัวข้อคือ รูปแบบการสื่อสารหรือติดต่อกันของ Processor งับ ซึ่งแบ่งได้ 2 รูปแบบ คือ
        - Bus-Based : อันนี้เอาง่ายๆ งับ คือ ทุกอย่างจะต้องมาใช้แค่ถนนกลางเส้นเดียว ถ้าถนนกลางพัง ก็เรียบร้อยคับ แตก ซึ่งระบบนี้ส่วนมากก็ใช้กับคอมยุคสมัยนี้แหละงับ
        - Switch-Based : ส่วนอันนี้ คือ ทุกๆ Processor อะคับเขามีทางเป็นของตัวเอง ฉะนั้นถ้าหากถนนเส้นใดเส้นนึงพัง ก็จะไม่ส่งผลต่ออันอื่นๆเหมือน ระบบ Bus ซึ่งระบบนี้ส่วนมากถ้าจะใช้ คือต้องมี Processor แบบ 1000 ตัวอัพอะคับ

    ```
* Read 17th chapters in slides **17-Multicore** finished 11:23 On 21/10/2023
:thought_balloon:
    ```
    คือในบทนี้อะคับ เราจะกล่าวคล้ายๆกับบทที่แล้วเลยนะ แต่ว่าในบทนี้จะมีการพูดถึงสองหัวข้อที่เพิ่มขึ้น นั่นก็คือ 
    <--> Parallelism : การทำงานแบบนี้ คือ การทำงานแบบแยกกันทำซึ่งสามารถอธิบายได้อีก 2 อย่างงับ นั่นคือ 
        - Task Parallelism : อันนี้คือการทำงานแบบว่า ในหนึ่งช่วงเวลาอะงับ เรามี หลายๆ process ทำงานพร้อมกัน ซึ่ง process เหล่านั้นก็แยกกันทำงานในแต่ละ core ด้วยทำให้ได้ผลลัพธ์ไม่เหมือนกัน แต่เราไม่ได้สนงับ เราสนแค่น้องทำงานแบบ Multicore ก็พอแล้วว ซึ่งแบบนี้เค้าเรียกว่า Task Parallelism
        - Data Parallelism : ต่อมาอันนี้คือ การทำงานแบบว่า ในหนึ่ง process อะงับ เราจะแบ่ง process นั้นออกเป็นส่วนๆ ให้แต่ละ core ได้ทำงาน ต่อจากนั้นเราจะเอาผลลัพธ์ที่ได้จากการทำงานของแต่ละ core เอามารวมกันงับ 
    <--> Memory Architecture : หัวข้อนี้ จะประมาณว่า เออการทำงานร่วมกันอะ ต้องใช้ข้อมูลช่ะม่ะ ซึ่งเราสามารถแบ่งการเข้าถึงข้อมูลได้ ดังนี้
        - Shared Memory : หัวข้อนี้ คือ การแชร์ข้อมูลให้แต่ละ core งับ แบบว่า มีที่เก็บข้อมูลเดียวเลย แล้วให้แต่ละ core เอาข้อมูลไปใช้สอยเอา ซึ่งปัญหาที่เกิดขึ้น คือ การเข้าถึงข้อมูลพร้อมกันงับ แต่ไม่ต้องกลัวเรามีวิธีแก้ซึ่งเรียกว่า "Synchronization Mechanisms"
        - Distributed Memory : ต่อมาวิธีนี้คือ การแบ่งเลยคับ เราจะให้แต่ละ core มีข้อมูลเป็นของตัวเองเลย หลักการมีแค่นี้แหละงับ
    ```
* Read 19th chapters in slides **19-Multithreaded** finished 15:08 On 21/10/2023
:jack_o_lantern:
    ```
    --> Multithreading Architecture : คือ การทำงานหลายๆ thread พร้อมกัน ซึ่งส่วนประกอบของการทำงานแบบ Multithread มีดังนี้
        - Program : ชุดคำสั่งที่ยังไม่ได้ทำงาน
        - Process : อันนี้คือ Program เวอร์ชัน ที่กำลังทำงานอยู่
        - Thread : อันนี้คือ หน่วยของ process 
        1 program : มีได้หลาย process และแต่ละ process มีได้หลาย Thread
    <--> Types of Multithreading : คือ ประเภทการทำงานของระบบ Multithread ซึ่งมีทั้งหมด 3 ประเภท ได้แก่
        - Coarse-Grained : ในเวลา 1 cycle จะทำทีละ Thread ให้เสร็จก่อน ซึ่งถ้าหาก Thread ที่กำลังทำอยูเกิดติดปัญหาเราจะทำ Thread ที่อยู่ต่อจากอันนี้ต่อ และถ้าติดปัญหา ก็ทำแบบเดิม
        - Fine-Grained : ใน 1 หน่วยเวลา ทุกๆ Thread จะมีความคืบหน้าพร้อมกันแบบวิแรก อันนี้ วิสองอีกอัน วิที่สามก็อีกอัน ทำสลับๆกันไป ทำให้ผลลัพธ์จะได้พร้อมๆกัน
        - Simultaneous : อันสุดท้ายนี่ดีที่สุดเลย เพระว่า ใน 1 หน่วยเวลาอะ ทุก Thread ทำหมดเลยพร้อมกัน ถ้าสังเกตุดีๆอะ สองอันแรกมันยังแบบเออ 1 วิ 1 อันนะ แต่อันนี้อะ 1 วิ หลายอันเลย ประมาณนี้ๆ
    ```
* Read 20th chapters in slides **20-Memory Synchronization** finished 21:54 On 21/10/2023 :foggy:
    ```
    --> Memory Synchronization : คือการที่แบบว่า Thread แต่ละ Thread ถ้าพวกเขาอยากขอเข้าถึงข้อมูลพร้อมกันอะ เราจะมีวิธีไหนบ้างที่ทำให้ข้อมูลนั้นมีความสมบูรณ์มากที่สุด ซึ่งเรามีวธีที่เรียกว่า
    <--> Synchronization Mechanisms ซึ่งมี 3 วิธีได้แก่
        - Locks/Mutexes : คือการที่ใช้เงื่อนไขกำหนดการเข้าถึงข้อมูลซึ่ง Thread สามารถเข้าได้แค่ 1 Thread เท่านั้นต่อ 1 ข้อมูล ซึ่ง Thread อื่นๆก็ต้องรอ
        - Semaphores : คือการที่เรากำหนดเลยว่า ในข้อมูลนี้อะ เราสามารถให้ Thread ใช้ได้พร้อมกันทั้งหมดกี่ตัว อาจจะ 1 2 3 หรือ 20 30 ตัวก็ว่าไป
        - Memory Barriers : ส่วนอันนี้อะคับเราจะไม่ได้จัดการกับ Thread และ แต่เราจะจัดการกับลำดับคำสั่งเลย พวกอ่านเขียนข้อมูลอะไรงี้ ให้มันมีการเรียงอย่างถูกต้อง
    ```
* Read 21st chapters in slides **21-Memory Consistency** finished 22:30 On 21/10/2023 :hatching_chick:
    ```
    <--> Consistency Models คือการเรียงลำดับของคำสั่งในการเข้าถึงพื้นที่หน่วยความจำซึ่งแบ่งได้ทั้งหมด 4 ประเภท ได้แก่
        - Strict : น้องเขาขอว่า ทั้งลำดับการทำงานและช่วงเวลาในการทำงานของลำดับคำสั่งอะ ต้องตรงกันไม่ว่าจะเป็น Process ไหนก็ตาม
        - Sequantial : ในส่วนนี้ดีกว่าอันที่แล้วตรงที่ว่า เราขอแค่ลำดับคำสั่งอะเหมือนเดิม แต่คุณจะเรียกเวลาไหนก็ได้แล้วแต่ process นั้นจะเรียก แต่ลำดับคำสั่งต้องเหมือนเดิมนะ เขาขอแค่นี้เลย
        - Weak : อันนี้จะเป็นแบบว่า ลำดับคำสั่งในการเรียกขอเข้าใช้พื้นที่อะสลับกันได้ถ้าหากลำดับคำสั่งนั้นอยู่ก่อน S(Sync point) ซึ่งมันจะส่งผลต่อลำดับผลลัพธ์ซึ่งก็ไม่เป็นไร แต่ถ้าหากลำดับคำสั่งที่เรียกหลัง S แล้วอะ ทุกๆคำสั่งต้องเป็นลำดับเดียวกันและต้องเรียกในช่วงเวลาที่ใกล้เคียงกันด้วย ใช้คำว่า ช่วงเวลานะ
        - Release : ตัวนี้เรียกได้ว่าเป็นตัวที่ยืดหยุ่นที่สุด และมีการใช้งานมากที่สุด เพราะว่า ระบบนี้ถูกใช้งานใน Lock/Mutexs โดยหลักการทำงานคือ Acq(Lock)->R/W Data->Release แล้วก็แบบนี้วนไปเรื่อยๆ
    ```
* Read 22nd chapters in slides **22-Memory Conherence** finished 23:05 On 21/10/2023 :pill:
    ```
    เรื่องนี้จะเป็นเรื่องที่อธิบายเกี่ยวกับการช่วยให้หน่วยความจำที่มีอยู่หลายๆที่ มีการที่ตรงกันหรือใกล้เคียงกันมากที่สุด ซึ่งวิธีนี้เรียกว่า
    <--> Coherence Protocols แบ่งได้ 4 วิธีได้แก่
        - MSI : Modifier, Shared, Invalid เป็นตัวบ่งบอกถึงสถานะที่ Cache สามารถเป็นได้
                > Modifier : คือ Cache ที่อยู่ในสถานะการแก้ไข ซึ่งตัว Modifier นี้จะมีตัวๆนึง ที่จะไปอัพเดตค่าใน Ram ให้ด้วย เพราะโดยปกติแล้ว Cache ก็จะไปเอาค่ามาจาก Ram นี่แหละ 
                > Shared : Cache ที่อยู่ในสถานะนี้จะเป็น Cache ที่อยู่ในสถานะที่ครอบครองค่าล่าสุดอยู่ ซึ่งถ้าหากว่า Cache อื่นมีการเปลี่ยนแปลงค่า ก็จะกลายเป็น Invalid
                > Invalid : คือ การที่ Cache ครอบครองค่าเก่าอยู่ หรือว่า Cache นี้ยังไม่มีการใส่ค่าอะไรเลย พอ CPU มาเรียก Cache นี้ก็ต้องแปลงไปเป็นสถานะ Share หรือ Modifier เพื่อเปลี่ยนแปลงตนเอง
        - MESI : เพิ่ม Exclusive เข้ามาคือ สามารถอ่านได้ในตัวแต่ต้องขออนุญาตการเข้าถึงข้อมูลจาก process อื่นๆก่อนนะ และ Cache ที่มีสถานะเป็น Exclusive จะสามาถรใช้ได้แค่ ตัวเดียวเท่านั้น ถ้ามีการใช้ >= 1 จะกลายเป็น Share แทน เพราะมันไม่ Exclusive หล่ะน้องๆ
        - MOSI : Owner ตัวนี้เทพมาก มีความสามารถในการอ่านและเขียนข้อมูลได้เลย ทำงานคล้ายๆกับ Ram เลย อีกอย่างค่าที่ได้จาก Cache ที่มีสถานะเป็น Owner อะยังเป็นค่าที่ล่าสุดอีกด้วย เทพจริงๆๆคับ
        - MOESI : อันนี้เทพสุด เพราะคุณสามารถอ่านและเขียนได้ในเวลาเดียวกัน
    ทั้งหมดที่กล่าวมานี้ล้วนเป็นการลดภาระที่ Cache จะต้องนำข้อมูลมาจาก Ram ทั้งสิ้น คือใจความสำคัญคือ เขาอยากลดเวลาในการเอาข้อมูลอะว่างั้น
    ```
* Read 23rd chapters in slides **23-Designing for Performance** finished 10:15 On 22/10/2023 :moon:
    ```
    เรื่องนี้เราจะกล่าวเกี่ยวกับว่า เออการที่คอมของเราจะแรงได้เนี่ยเราต้องสูญเสียอะไรบ้าง หรือว่า ต้องวัดอย่างไรบ้าง
    <--> Performance Metrics คือการที่บอกว่า เออถ้าเราอยากจะรู้ว่าคอมเรามีประสิทธิภาพแค่ไหนอะ ต้องวัดอะไรบ้าง
        - Execution Time : เราจะใช้เวลาเท่าไรกัน ถึงจะได้มาเป็นผลลัพธ์ ซึ่งเราอยากให้น้องใช้เวลาน้อยๆ
        - Throughput : อันนี้อะเราต้องการจะสื่อว่า เออ ในช่วงใน cycle นึงเนี่ยมีกี่คำสั่งที่ถูกทำงาน ซึ่งเราอยากให้ในหนึ่งหน่วยเวลาเนี่ย มีการทำคำสั่งเยอะๆ เลย
        - Latency : อันสุดท้ายนี้จะเป็นความหน่วงงับ เช่น แบบว่า เออเวลาเราขยับเมาส์อะไรอย่างงี้อะ cursor แบบมีดีเลย์ไหม หรือว่า ทันทีเลย ซึ่งถ้าค่า Latency ต่ำก็ดีมากเพราะเราต้องการแบบนั้น แต่ถ้าหาก Latency สูงแปลว่าหน่วงเยอะก็ต้องแก่
    <--> Trade-offs คือประมาณว่า แล้วถ้าเราอยากจะให้คอมของเราแรงขึ้นอะ เราต้องสูญเสียหรือต้องคำนึงถึงอะไรบ้าง
        - Physical Size : คือขนาดงับ ในตอนนี้อะ ขนาดของ CPU เริ่มที่จะคงที่แล้ว แต่ถ้าหากว่า ยังต้องการจะให้เร็วขึ้นเราก็ต้องเพิ่ม HW ซึ่งการเพิ่มก็ส่งผลต่อขนาดเช่นกัน
        - Power : พลังงานที่ใช้ ยิ่งเราอยากได้ความเร็วที่มากขึ้น พลังงานที่ใช้ก็ยิ่งสูงขึ้น พลังงานไฟฟ้า ว่ากันตามตรง
        - Cost : อันนี้ คือ ราคางับแบบว่า ราคาทุกอย่างเลย ทั้งค่าไฟ ค่าราคาสิ้นค้าที่เราซื้อเพื่อแลกมากับความเร็วและแรงตามที่เราต้องการ ยิ่งอยากได้ของดี ราคาก็ต้องแพง แลกๆกันไป
        - Compatibility : อันสุดท้ายนี้จะเกี่ยวกับแบบว่า เออถ้าแบบว่าเราเอาอุปกรณ์มายำรวมกันเพื่อที่จะได้ความเร็วที่เพิ่มขึ้นอะ อุปกรณ์เก่าๆ อะ จะลองรับป่ะ หรือว่าเขาเข้ากันได้ดีไหม เพราะถ้าเข้ากันไม่ค่อยดี ก็ไม่ช่วยช้าเหมือนเดิม อะไรประมาณนี้งับ
    ```

### Software Construction Lecture :hotsprings:
> * :izakaya_lantern: [ROYALTY](#zap-ticking-away--zap) :fireworks:


### Data Structure :open_file_folder:
> * :milky_way: [ANOTHER DIMENSION](#zap-ticking-away--zap) :dizzy:
* Read 13rd chapters in slides **13-Graphs** finished 15:26 On 22/10/2023 :sleeping:
    > * :sob:[Adjacency Matrix Code](Data-Structures/R(U)EADY/13-Graph/)
    > * :joy:[Basic Operation on Adjacency Matrix Graph by C](Data-Structures/R(U)EADY/13-Graph/)
    ```
    เรื่องนี้จะอธิบายเกี่ยวกับ Graph เลยคับว่า เออกราฟมีแบบ 2 ประเภทน้า
        - vertices(nodes) : จุดตัด หรือ จุดในกราฟ
        - edges(arcs) : เส้นเชื่อม
    --> กราฟไม่มีทิศทาง(Undirect Graph) : เป็นกราฟที่ประกอบไปด้วยเส้นเชื่อมที่ไม่มีทิศทาง
        - end-vertices(end point) : มันคือแบบ 1 เส้นเชื่อมที่มีโหนด สอง โหนด
        - adjacent : มันคือ node ที่มีเส้นเชื่อมต่อกับ node นี้
        - incident : 1 node มีกี่ edges ที่เชื่อมอยู่
        - degree : เส้นที่ออกและเข้าจาก node นี้
    --> กราฟมีทิศทาง(Direct Graph) : เป็นกราฟที่ประกอบไปด้วยเส้นเชื่อมที่มีทิศทาง
        - origin : จุดเริ่มต้นของ edge
        - destination : จุดจบของ edge ปลายลูกศร
        - outgoing edges(out-degree) : เส้นที่พุ่งออกจาก node
        - incoming edges(in-degree) : เส้นที่พุ่งเข้าหา node
    ต่อมาก็จะพูดถึงเรื่องแบบ เออเราสามารถอธิบายกราฟเป็นรูปแบบของ
        - Matrix
        - List
    จบครับบทแรก เรื่องกราฟ
    ```
* Read 14th chapters in slides **14-Graphs** finished 22:41 On 22/10/2023 :sleepy:
    > * :cry:[Adjacency List Code](Data-Structures/R(U)EADY/14-Graph/)
    > * :revolving_hearts:[Basic Operation on Adjacency List Graph by C++](Data-Structures/R(U)EADY/14-Graph/)
    ```
    --> ข้อดี และ ข้อเสียของ Graph
        - Adjacency Matrix : มักใช้กับกราฟที่มีความแน่นของเส้นเชื่อมมาก และช้าในการเพิ่มและลบจุดในกราฟ
        - Adjacency List : มักใช้กับกราฟที่มีความแน่นของเส้นเชื่อมน้อย และช้าในการเพิ่มเส้นเชื่อมในกราฟ
    ```
* Read 15th chapters in slides **15-GraphTraversal** finished 09:06 On 24/10/2023 :dizzy_face:
    > * :hankey:[Solution DFS-Depth First Search](Data-Structures/R(U)EADY/15-GraphTraversals/)
    > * :poop:[DFS Implementation by C++](Data-Structures/R(U)EADY/15-GraphTraversals/)
    ```
    --> เรื่องนี้จะอธิบายเกี่ยวกับ การท่องกราฟ ด้วยวิธี DFS(Depth-First-Search) ซึ่งคำที่ประกอบในบทนี้ก็จะมี
        - Path : เส้นทางของ Node ที่เชื่อมด้วยกัน
        - Cycle : เส้นเชื่อมที่มากกว่าเท่ากับ 1 เส้นเชื่อมโยงมาหาโหนดเดียวกัน
        - path's length : ความยาวของเส้นเชื่อม หาได้จาก Node - 1
        - Connected graph : กราฟที่มี Node ทุก Node เชื่อมโยงถึงกัน
        - Connected components : แต่ถ้าไม่ได้เชื่อมถึงกัน ทุก Node ก็เรียกคำนี้แหละงับ
    --> ทฤษฎีการเดินทางแล้วยังรู้เส้นทางที่ตัวเองเดินเรียกว่า Tremaux's Algorithm
    --> ตัวอย่างการทำ Depth-Firsh-Search มีให้อยู่ไฟล์โค๊ด และ รูปภาพแล้วงับเป็นการทำ DFS ใน Undirected Graph นะงับ
    --> Complexity of DFS is O(n)
    ```
* Read 16th chapters in slides **16-GraphTraversal** finished 11:58 On 24/10/2023 :alien:
    > * :innocent:[Solution BFS-Breate First Search](Data-Structures/R(U)EADY/16-GraphTraversals/)
    > * :sunglasses::[BFS Implementation by C++](Data-Structures/R(U)EADY/16-GraphTraversals/)
    ```
    --> Complexity of BFS is O(n)
    --> BFS การันตีเลยว่า เส้นทางที่เขาให้จะเป็นเส้นที่ทางดีที่สุด แต่ DFS ไม่การันตี เพราะฉะนั้น BFS จึงเหมาะกับการใช้หาเส้นทางใน GPS
    ```
* Read 17 && 18 th chapters in slides **17 && 18-Trees** finished 14:19 On 24/10/2023 :tired_face:
    > * :pensive:[Basic Operation on Ordered Trees by C](Data-Structures/R(U)EADY/17&18-Trees/)
    ```
    ในบทนี้บอกว่า Tree ที่เอามาสอนมีอยู่ 3 ประเภท ได้แก่
        - Free Trees : คือ ต้นไม้ที่เป็น Undirect graph งับ ไม่มี cycle และสมาชิกจะอยู่บนหรือล่างก็ได้ แล้วแต่
        - Rooted Trees : ส่วนอันนี้คือ ต้นไม้ที่เป็น Direct graph งับ มีส่วนประกอบของต้นไม้ประเภทนี้ คือ 
            - Ancestor : จำนวน node ทุกโหนดที่อยู่บน node x 
            - Descendant : จำนวน node ทุกโหนดที่อยู่ล่าง node x รวมตัวเองด้วยนะ
            - Subtree : ต้นไม้ย่อย
            - Parent : คือ โหนดที่อยู่ข้างบน path ก่อน ถึง x นั่นแหละคับ parent
            - Child : node ที่อยู่ล่าง parent คับ แค่ชั้นเดียวนะ
            - Siblings : node ที่มี parent คนเดียวกัน
            - Leaf(External Node) : node ที่ไม่มีลูก
            - internal Node : node ที่มีลูก
        ส่วนเรื่องคุณสมบัติ ของ Rooted Trees ก็ได้แก่
            - Degree : จำนวนลูกของ node นั้นๆ 
            - Depth : ความสูงนับจากตัวเองขึ้นไปหา Root(r) ให้ตัวเองเป็น 0 นะงับ
            - Level : มันเป็นแบบ Level ง่ะ Depth ที่เท่ากัน คือ level เดียวกัน 
            - Height : ความสูงของ node นั้น ก็คือ นับจากตัวเอง ลงไปข้างล่าง หาเส้นที่ยาวที่สุด ให้ตัวเองเป็น 0 นะงับ
        - Ordered Trees : concept นี้เหมือนกับ Rooted Tree เลย แต่ต่างกันตรงที่ 
            - Orderd Trees : เรียงค่าจากน้อยไปมาก
            - Rooted Trees : ไม่ได้เรียงค่า
    ```