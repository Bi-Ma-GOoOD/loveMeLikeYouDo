# :crown: Place it a top my own hand :crown:

## :fire: FINAL OPERATING SYSTEM :fire:

> :trophy: Glory
> * :lock: [DeadLock](#deadlock-lock_with_ink_pen) :old_key:
> * [Virtual-Memory]
> * [File-System]
> * [I/O]
> * [Security]

### :zap Baby We're :zap
![This is picture.](/Images/Inspiration_n_love/GODS.jpg "Go Go GOD!!!")

### Deadlock :lock_with_ink_pen:
> * :crystal_ball: [Teleport](#crown-place-it-a-top-my-own-hand-crown) :milky_way:
```
    Pages(1-25)
        > (8)Resource Categorise มี 2 ประเภท ได้แก่
            - Reusable Resource คือ การที่อาจจะมี process นึงสร้างขึ้นมาหรือว่ามีอยู่แล้ว แต่เมื่อ process นั้นใช้ resource นี้เสร็จแล้วมันไม่ได้หายไป เช่น I/O, Memory, Database และอื่นๆ
            - Consumable Resource คือ การที่มี process สร้างขึ้นมาเหมือนกันเลยแต่ว่า พอใช้เสร็จแล้วอะ resource ประเภทนี้จะหายไป เช่น Signals, Interrupts และอื่นๆ
        ** Consumable Resource มีโอกาสเกิด Deadlock ต่ำกว่า Reusable
        > (17)เงื่อนไขที่ทำให้เกิด Deadlock มี 4 เงื่อนไข
            1. Mutual Ex : คือการที่ให้ process นั้นใช้ resource เพียง 1 process เท่านั้นซึ่งอาจจะทำให้ process อื่นๆต้องรอ เมื่อเกิดการรอจน process นั้นมันไม่ได้ทำงานก็เป็นส่วนนึงที่ทำให้เกิด Deadlock
            2. Hold and Wait : คือการที่มี process นึงถือ resource ไว้แล้ว 1 อย่าง แต่ process นี้อะต้องการ 2 resource เป็นอย่างต่ำในการทำงานทำให้เขาต้องรอ process ที่เขาต้องการด้วย เพื่อที่จะได้ทำงาน ซึ่งในขณะเดียวกัน process อื่นๆ ก็ต้องการ resource ที่ process นี้ครอบครองไว้เหมือนกัน มันเลยติดทำอะไรต่อไม่ได้
            3. No pre-emption : คือการที่เราไม่ยอมแย่ง resource ของคนที่เขาติด Deadlock อยู่มาเป็นของตนเอง ทำให้เราก็ต้องรอด้วยก็ติดทำอะไรไม่ได้ค้าง...
            4. Circular wait : คือการที่มี process หลายๆ process ต้องการ resource ของกันและกันจนเหมือนมันไล่ตามหลังกันเองจนเกิดเป็น cycle ดูหน้า(21)
        *** จะเกิดเงื่อนไขได้ต้องมี 4 เงื่อนไขเท่านั้น ถ้ามีแค่ 3 อันแรกยังมีโอกาสน้อย แต่ถ้าอัน 4 มาร่วมวงเมื่อไรก็จบเห่ แตกคับ
        > (25)Resource Allocation Graph น้องคือ การดู Deadlock แบบกราฟจำไว้เลยคับ หลักการดูง่ายๆ ถ้าหากว่าต่อให้กราฟนั้นเป็น Cycle แต่ถ้าหากมี process ใด process นึงที่เขาสามารถทำงานได้ หรือว่าถ้าเขาได้ resource ครบแล้ว ก็ไม่ถือว่าเกิด Deadlock
            - แล้วจะรู้ได้ไงว่า process นั้นไม่ต้องการ resource แล้ว?
                ตอบ : ถ้าหากว่าไม่มีลูกศรชี้อออกจากตัวเขาแล้วอะ มีแต่ชี้เข้าแสดงว่าเขาสามารถทำงานได้เลย แล้วพอเขาทำเสร็จเขาก็จะคืน resource เอง
            - อีกอย่างนึงคือ ถ้าหากว่าใน resource นั้นมีหลายๆ instance ก็อาจจะไม่ทำให้เกิด Deadlock ได้ถ้ามันเพียงพอต่อความต้องการของ process
    Pages(26-จนจบ ไม่นับ Unix เด้อไม่ได้สอน)
        > เริ่มแรกเขาต้องการจะสื่อว่า การจัดการกับ Deadlock อะ มี 4 ประเภท ได้แก่
            1. Deadlock Prevention : เอาง่ายๆ อันนี้คือพยายามที่จะทำให้เงื่อนไขการเกิด Deadlock ที่เรากล่าวมาแล้วอันบนอะ ทั้ง 4 อันอะ มันเป็นเท็จ ซึ่งแม่งทำยากมาก และค่อนข้างที่จะมี Overhead สูงเพราะเราต้องทำล่วงหน้าก่อนที่จะเกิด Deadlock อย่างแบบ
                - Mutual Ex : บาง resource อะเราไม่สามารถทำให้เขาเป็น single ได้อะ แบบสามารถแชร์ได้เช่น อย่าง printer, cpu อะไรแบบนี้มันต้องทีละคน
                - Hold and Wait : อันนี้เขาก็พยายามจะแบบเออ แทนที่มึงจะรอในสิ่งที่มึงไม่มี ถ้างั้นเอางี้มึงบอกกูมาเลย ว่าอยากได้อะไรบ้าง แล้วเอาไปเลยทีเดียว ซึ่งมันส่งผลกระทบต่อการใช้ทรัพยากรที่ไม่มีประสิทธิภาพเพราะต้องมาเตรียมอะไรที่แบบมึงยังไม่ได้ใช้ ณ ขณะเวลานั้นอะ แต่โดยรวมแล้วใช้หมด
                - No-pre-emption : ก็คือแบบถ้า resource ที่คุณขอยังไม่มีถ้างั้นให้คุณทิ้งทุกอย่างที่คุณมีเลย แล้วค่อยรวมใหม่ โหพ่อมึงอะ กูต้องรวมใหม่มันนานมั้ยย
                - Circular Wait : อันนี้แก้ง่ายหน่อยแต่รวมๆแล้วก็ยาก คือหลักการมันประมาณว่า process แต่ละอันต้องเอา resource ที่มีลำดับที่สูงขึ้นเท่านั้นจะต่ำกว่า resource ที่ตนเองครอบครองอยู่ ณ ขณะนี้ไม่ได้ แต่บาง process อะเขาก็จำเป็นจริงๆ ที่ต้องใช้ resource ที่ต่ำกว่าที่ตนเองครอบครองอยู่ อะไรประมาณนี้
            2. Deadlock Avoidance : ส่วนอันนี้คือ เป็นสูตรคำนวณ Banker Algorithm งับใช้ค่าจากอนาคตเพื่อหาความเป็นไปได้ว่า ถ้าเกิดให้ resource กับ process นี้แล้วจะส่งผลให้ระบบอยู่ใน unsafe ไหม ถ้าให้แล้วเป็น unsafe ก็ไม่ให้ แต่ถ้าให้แล้ว safe เราก็ให้ต่อ วิธีนี้ก็มี overhead สูงเพราะต้องทดลองแล้วก็คำนวณก่อน เป็นวิธีที่หลีกเลี่ยงการเกิด Deadlock ล่วงหน้าเหมือนกัน ดูภาพหน้า(44)
            3. Deadlock Detection : อันนี้คือ รอให้ Deadlock เกิดก่อนแล้วค่อยจัดการ ซึ่งวิธีจัดการของพี่เขามี 4 อย่าง
                1. สั่งหยุดการทำงานทุก process แล้วกลับไปเริ่มทำงานใหม่ตั้งแต่จุดเริ่มต้น
                2. ถอยหลังกลับไป 1 ก้าว ถ้าถอยหลังกลับไป checkpoint ล่าสุดที่มาแล้วยังเกิด Deadlock อยู่ก็กลับไปอีกจนกว่าจะไม่เกิด
                3. ไล่สั่งหยุดการทำงานทีละ process จนกว่าจะไม่เกิด Deadlock
                4. ขอยึด resource จาก process ที่เกิดหรือไม่เกิด Deadlock เพื่อทำให้ Deadlock มันหายไป
            4. Ostrich Algorithm : ไม่ทำอะไรเลยคับน้องๆชิวๆอะคับอืมมมม
```