# :crown: Place it a top my own hand :crown:

## :fire: FINAL OPERATING SYSTEM :fire:

> :trophy: Glory
> * :lock: [DeadLock](#deadlock-lock_with_ink_pen) :old_key:
> * :open_file_folder:[Virtual-Memory](#virtual-memory-management-post_office):card_index_dividers:
> * [File-System]
> * [I/O]
> * [Security]

### :zap: Baby We're :zap:
![This is picture.](/Images/Inspiration_n_love/GODS.jpg "Go Go GOD!!!")

### Deadlock :lock_with_ink_pen:
> * :crystal_ball: [Teleport](#crown-place-it-a-top-my-own-hand-crown) :milky_way:
```
    Pages(1-25)
        > (8)Resource Categorise มี 2 ประเภท ได้แก่
            - Reusable Resource คือ การที่อาจจะมี process นึงสร้างขึ้นมาหรือว่ามีอยู่แล้ว แต่เมื่อ process นั้นใช้ resource นี้เสร็จแล้วมันไม่ได้หายไป เช่น I/O, Memory, Database และอื่นๆ
            - Consumable Resource คือ การที่มี process สร้างขึ้นมาเหมือนกันเลยแต่ว่า พอใช้เสร็จแล้วอะ resource ประเภทนี้จะหายไป เช่น Signals, Interrupts และอื่นๆ
        ** Consumable Resource มีโอกาสเกิด Deadlock ต่ำกว่า Reusable
        > (17)เงื่อนไขที่ทำให้เกิด Deadlock มี 4 เงื่อนไข
            1. Mutual Ex : คือการที่ให้ process นั้นใช้ resource เพียง 1 process เท่านั้นซึ่งอาจจะทำให้ process อื่นๆต้องรอ เมื่อเกิดการรอจน process นั้นมันไม่ได้ทำงานก็เป็นส่วนนึงที่ทำให้เกิด Deadlock
            2. Hold and Wait : คือการที่มี process นึงถือ resource ไว้แล้ว 1 อย่าง แต่ process นี้อะต้องการ 2 resource เป็นอย่างต่ำในการทำงานทำให้เขาต้องรอ process ที่เขาต้องการด้วย เพื่อที่จะได้ทำงาน ซึ่งในขณะเดียวกัน process อื่นๆ ก็ต้องการ resource ที่ process นี้ครอบครองไว้เหมือนกัน มันเลยติดทำอะไรต่อไม่ได้
            3. No pre-emption : คือการที่เราไม่ยอมแย่ง resource ของคนที่เขาติด Deadlock อยู่มาเป็นของตนเอง ทำให้เราก็ต้องรอด้วยก็ติดทำอะไรไม่ได้ค้าง...
            4. Circular wait : คือการที่มี process หลายๆ process ต้องการ resource ของกันและกันจนเหมือนมันไล่ตามหลังกันเองจนเกิดเป็น cycle ดูหน้า(21)
        *** จะเกิดเงื่อนไขได้ต้องมี 4 เงื่อนไขเท่านั้น ถ้ามีแค่ 3 อันแรกยังมีโอกาสน้อย แต่ถ้าอัน 4 มาร่วมวงเมื่อไรก็จบเห่ แตกคับ
        > (25)Resource Allocation Graph น้องคือ การดู Deadlock แบบกราฟจำไว้เลยคับ หลักการดูง่ายๆ ถ้าหากว่าต่อให้กราฟนั้นเป็น Cycle แต่ถ้าหากมี process ใด process นึงที่เขาสามารถทำงานได้ หรือว่าถ้าเขาได้ resource ครบแล้ว ก็ไม่ถือว่าเกิด Deadlock
            - แล้วจะรู้ได้ไงว่า process นั้นไม่ต้องการ resource แล้ว?
                ตอบ : ถ้าหากว่าไม่มีลูกศรชี้อออกจากตัวเขาแล้วอะ มีแต่ชี้เข้าแสดงว่าเขาสามารถทำงานได้เลย แล้วพอเขาทำเสร็จเขาก็จะคืน resource เอง
            - อีกอย่างนึงคือ ถ้าหากว่าใน resource นั้นมีหลายๆ instance ก็อาจจะไม่ทำให้เกิด Deadlock ได้ถ้ามันเพียงพอต่อความต้องการของ process
    Pages(26-จนจบ ไม่นับ Unix เด้อไม่ได้สอน)
        > เริ่มแรกเขาต้องการจะสื่อว่า การจัดการกับ Deadlock อะ มี 4 ประเภท ได้แก่
            1. Deadlock Prevention : เอาง่ายๆ อันนี้คือพยายามที่จะทำให้เงื่อนไขการเกิด Deadlock ที่เรากล่าวมาแล้วอันบนอะ ทั้ง 4 อันอะ มันเป็นเท็จ ซึ่งแม่งทำยากมาก และค่อนข้างที่จะมี Overhead สูงเพราะเราต้องทำล่วงหน้าก่อนที่จะเกิด Deadlock อย่างแบบ
                - Mutual Ex : บาง resource อะเราไม่สามารถทำให้เขาเป็น single ได้อะ แบบสามารถแชร์ได้เช่น อย่าง printer, cpu อะไรแบบนี้มันต้องทีละคน
                - Hold and Wait : อันนี้เขาก็พยายามจะแบบเออ แทนที่มึงจะรอในสิ่งที่มึงไม่มี ถ้างั้นเอางี้มึงบอกกูมาเลย ว่าอยากได้อะไรบ้าง แล้วเอาไปเลยทีเดียว ซึ่งมันส่งผลกระทบต่อการใช้ทรัพยากรที่ไม่มีประสิทธิภาพเพราะต้องมาเตรียมอะไรที่แบบมึงยังไม่ได้ใช้ ณ ขณะเวลานั้นอะ แต่โดยรวมแล้วใช้หมด
                - No-pre-emption : ก็คือแบบถ้า resource ที่คุณขอยังไม่มีถ้างั้นให้คุณทิ้งทุกอย่างที่คุณมีเลย แล้วค่อยรวมใหม่ โหพ่อมึงอะ กูต้องรวมใหม่มันนานมั้ยย
                - Circular Wait : อันนี้แก้ง่ายหน่อยแต่รวมๆแล้วก็ยาก คือหลักการมันประมาณว่า process แต่ละอันต้องเอา resource ที่มีลำดับที่สูงขึ้นเท่านั้นจะต่ำกว่า resource ที่ตนเองครอบครองอยู่ ณ ขณะนี้ไม่ได้ แต่บาง process อะเขาก็จำเป็นจริงๆ ที่ต้องใช้ resource ที่ต่ำกว่าที่ตนเองครอบครองอยู่ อะไรประมาณนี้
            2. Deadlock Avoidance : ส่วนอันนี้คือ เป็นสูตรคำนวณ Banker Algorithm งับใช้ค่าจากอนาคตเพื่อหาความเป็นไปได้ว่า ถ้าเกิดให้ resource กับ process นี้แล้วจะส่งผลให้ระบบอยู่ใน unsafe ไหม ถ้าให้แล้วเป็น unsafe ก็ไม่ให้ แต่ถ้าให้แล้ว safe เราก็ให้ต่อ วิธีนี้ก็มี overhead สูงเพราะต้องทดลองแล้วก็คำนวณก่อน เป็นวิธีที่หลีกเลี่ยงการเกิด Deadlock ล่วงหน้าเหมือนกัน ดูภาพหน้า(44)
            3. Deadlock Detection : อันนี้คือ รอให้ Deadlock เกิดก่อนแล้วค่อยจัดการ ซึ่งวิธีจัดการของพี่เขามี 4 อย่าง
                1. สั่งหยุดการทำงานทุก process แล้วกลับไปเริ่มทำงานใหม่ตั้งแต่จุดเริ่มต้น
                2. ถอยหลังกลับไป 1 ก้าว ถ้าถอยหลังกลับไป checkpoint ล่าสุดที่มาแล้วยังเกิด Deadlock อยู่ก็กลับไปอีกจนกว่าจะไม่เกิด
                3. ไล่สั่งหยุดการทำงานทีละ process จนกว่าจะไม่เกิด Deadlock
                4. ขอยึด resource จาก process ที่เกิดหรือไม่เกิด Deadlock เพื่อทำให้ Deadlock มันหายไป
            4. Ostrich Algorithm : ไม่ทำอะไรเลยคับน้องๆชิวๆอะคับอืมมมม
```

### Virtual Memory Management :post_office:
> * :crystal_ball: [Teleport](#crown-place-it-a-top-my-own-hand-crown) :milky_way:
```
    > คลิปแรก(ไฮไลต์สีฟ้า)
        คือในคลิปแรกอะมันจะประมาณว่า ในการจัดการพื้นที่อะคับ เวลาเราเอา process เข้ามาอะ เราเอาเข้ามาทั้ง process เลย ซึ่ง process เหล่านั้นจะอยู่ในพื้นที่ที่ os จัดไว้ให้เรียกว่า "partition" ซึ่งในช่วงแรกของการเอา process เข้ามานั้นเราจะมีการกำหนดขนาด และจำนวนของ partion เราเรียกว่า "fix partition" ต่อจากนั้นเวลา process ที่เราเอาเข้ามาเนี่ยเราจะเอาเข้ามาทุกส่วนทั้งหมด และทุกๆส่วนต้องอยู่ติดกันไม่สามารถแยกออกจากกันได้ เราเรียกว่า "Contiguous Allocation" ต่อจากนั้นเวลาเราจะ switch เอา process ที่ไม่ใช่ออกเราก็ใช้การ "swap-in || swap-out" ซึ่งการ swap นี้ทำผ่าน I/O จึงมี overhead ที่สูง นอกจากนี้ยังมีศัพท์อื่นๆที่สำคัญอีก เช่น
            - Internal Fragmentation : คือ พื้นที่ที่เหลือใน block partition เช่น block นึงมีขนาด 4 KB แต่โปรแกรมเราใช้แค่ 3 KB เท่ากับว่าเราเหลือพื้นที่ภายในอีก 1 KB ซึ่งมันเป็นขยะอะไม่ค่อยดีเท่าไร
            - External Fragmentation : มันจะเกิดจากการที่เราใช้หลักการ Contiguous Allocation ทำให้เราต้องเอาทั้ง process เข้ามาซึ่ง process ไม่ได้ดีขนาดเท่ากันทุกอัน จึงทำให้เกิดช่องว่างของพื้นที่ที่ไม่สามาถใช้งานได้
            - Memory Compaction(Defragmentation) : คือการรวบรวม พื้นที่ส่วนที่ว่างและส่วนที่ทำงานให้อยู่ด้วยกัน ส่วนถ้าเป็น Disk เราจะเรียกว่า Disk Defragmentation
            - Room for Growth(Heap) : คือขนาดของ process ที่จำเป็นต้องเผื่อใว้ให้ทุกๆ process เผื่อเอาไว้ใช้คำนวณหรือมีการใช้ malloc เอาง่ายๆ น้องคือ heap
            - Base และ Bound Register : เนื่องจากว่า process ของเราจะถูกเก็บไว้ใน physical addr. แต่ว่าเวลาเราจะอ้างอิงตำแหน่งหรือค่า offset อะไรอะ เราจะใช้ relation ในการทำ ซึ่ง Bound คือ พื้นที่เริ่มต้นของ process นั้นและ Bound คือ ขนาด หรือ size ของ process
            - Reallocation : คือการที่ process ของเราจะใช้เลขอ้างอิงตรงนี้เพื่อเอาไปใช้กับ process ที่อยู่ใน physical addr. จริงๆ
            - Protection : คือการป้องกันเพื่อไม่ให้ process มีการเข้าถึงตำแหน่งข้อมูลที่ไม่ใช่ของตัวเอง เช่น เวลาใช้เลข offset นี่แหละ
        สุดท้ายและ OS ใช้ Datastructure ในการติดตามการใช้พื้นที่บนหน่วยความจำของ process ที่ชื่อว่า
            1. Bit-Map : 1 bit : 1 block
            2. Linked List : 1 node : 1 process or hole(empty space)
        คือหลักๆ มันก็จะประมาณนี้แหละแบบว่า block ก็คือ partition ที่มีการกำหนดขนาดเอาไว้นั่นแหละ ต่อให้เป็น Dynamic partition สุดๆท้ายก็ต้องมีการกำหนดขนาดอยู่ดี ซึ่งก่อนที่เราจะไปเรื่อง Virtual Mem เราต้องพูด 2 สิ่งนี้ก่อนว่าเรามีน้อน Virtual Mem ทำไม
            1. process สามารถเข้ามาเป็นส่วนๆได้ Non-Contiguous Allocation เพราะว่าจริงๆแล้ว process ไม่ได้ใช้เต็มที่ทั้งหมด และบางที่ขนาดของ process ก็ใหญ่มากกว่าพื้นที่ว่างภายใน mem ด้วยซ้ำเลยจำเป็นที่จะต้องนำเอาเข้ามาทีละส่วน ซึ่งการนำเข้ามานั้นก็อ้างอิงจาก Locality หรือ การเข้าถึงข้อมูลที่ถูกเข้าบ่อย หรือ การเข้าใช้ข้อมูลส่วนนี้ที่เป็นกระจุกๆ
            2. Virtual Mem : จริงๆแล้วอยู่บน Disk แต่เหตุผลที่ process สามารถทำงานได้เพราะว่า Virtual ดึงแค่บางส่วนที่มีการใช้งานจริงๆ มาไว้บนหน่วยความจำเฉยๆ
            CPU -RalativeAddr-> MMU -PhysicalAddr-> Cache -> Mem -> Disk
    > คลิปที่สอง(ไฮไลต์สีเหลือง)
        คลิปที่สองจะกล่าวเกี่ยวกับคำสำคัญก่อน ได้แก่
            - page : ช่องที่ถูกแบ่งจาก paging ซึ่งเป็นส่วนนึงของ os เป็นคนจัดการ
            - frame : เป็นช่องที่ถูกแบ่งเหมือนกัน ซึ่งขนาดของ page = frame
            - page table entry : คือ table ที่ทำหน้าที่ mapping ค่าของ page number ไปหา frame โดยพื้นที่ของ page table จะติดกันแต่ส่วนของ frame ที่เราจะเอามา map นั้นไม่จำเป็นต้องเป็นพื้นที่ที่ติดกันก็ได้
            - Address Translation : คือการแปลงค่าจาก Virtual Addr./Logical Addr./Ralative Addr. คือตัวเดียวกันทั้งสิ้นที่ถูกส่งมาจาก CPU แล้วทำการแปลงผ่าน page table ซึ่งดูได้จากหน้า 39 - 42
            - Translation Lookaside buffer : น้อนเปรียบเสมือน cache ที่คอยเก็บ page number ที่ถูกเข้าถึงไว้ตลอดที่ด้วยความที่น้องเป็น cache จึงทำให้ไม่สามารถที่จะเก็บ page number ที่ถูกเข้าถึงทั้งหมดได้ เลยอาจจะทำให้เกิด Cache miss บ้าง ซึ่งถ้าเกิด cache miss การเอา content ก็ต้องผ่าน main mem ทั้งหมด 2 รอบ แต่ว่าถ้าเกิด Cache Hit ก็จะเหลือการเข้า Main Mem แค่รอบเดียว
            - Effective Access Time : (1+epilon)alpha + (2+epsilon)(1-alpha)
                1 มาจากเราเข้าถึง memory แค่รอบเดียว
                epilson : คือค่าของเวลาที่ TLB ใช้ Look up
                alpha : TLB Hit
                2 มาจากการที่เราพลาดจาก TLB Hit ทำให้ต้องเข้าถึง mem 2 รอบ
                    รอบแรกเอา physical addr.
                    รอบสองเอา content จาก physical addr. ที่ได้
    > คลิปที่สาม(ไฮไลต์สีฟ้าเขียว)
        คือเอางี้ก่อน การจัดการกับ page อะคับเรามีหลายวิธีมาก ซึ่งวิธีที่เราเรียนก็มี
            1. Page table Entry
            2. Inverted Page Tables : อันนี้คือ การแมพด้วยการส่ง process_id กับ page_number ที่ตัวเองต้องการจากนั้นนับสองตัวนี้ให้ไปหาใน page table ถ้าเจอที่ page ไหนให้เอาระยะห่างระหว่างตัวแรกจนถึงตัวที่เราต้องการเก็บไว้เป็นระยะห่าง ในตัวแปร i จากนั้น เอาตัวแปร i + off-set ก็จะได้ physical addr.
        แล้วก็มีการอธิบายเกี่ยวกับ page fault เนื่องจากว่าการทำ page ของเรา ณ ตอนนี้อะ เราทำแบบ demanding page หมายความว่าเราจะเอา page เท่าที่ใช้เท่านั้นเข้ามาจากนั้น เมื่อ cpu ส่ง virtual addr. มาแล้วไม่เจอการ map กันระหว่าง page_number และ frame ก็ต้องทำให้ MMU ซึ่งเป็น Hardware ส่ง page_fault_interupts ไปให้ OS จากนั้น OS จะทำการเปลี่ยน state of process form running -> blocking state เพื่อรอให้ I/O นับ frame มาแมพไว้บนหน่วยความจำ คือ I/O เขาทำงานนานเอาง่ายๆ จากนั้น OS ก็จะเรียกใช ้Dispatcher เพื่อให้ CPU ได้ทำงานต่อ
            M-Bit(Dirty-Bit) : การบ่งบอกว่า page นั้นถูก modifield ไหมถ้าถูก modified ก่อนที่จะถูก replace หรืออะไรก็ตามต้องมีการส่ง I/O Request เพื่อเป็นการเขียนข้อมูลกลับลงดิสก่อนแล้วค่อยเกิดการ replace
            R-Bit : คือการที่บอกว่า ณ ช่วงเวลาล่าสุด หรือ clock tick ล่าสุด page นี้ถูกใช้งานหรือไม่โดยทุกๆ clock tick R-Bit จะ set = 0 เสมอ แต่ถ้าหากถูกใช้งานก็เป็น 1
        ต่อมา คือ Basic Replacement policy คือหลักการนี้บอกเราว่า ในยามที่เกิด page fault อะ มันมีสองทางว่าจะเอายังไงดี ระหว่าง
            1 : ถ้าหากว่า page นั้นมีค่า m-bit = 0 ก็ทำการ replace ได้เลย
            2 : ถ้าหากว่า page นั้นมีค่า r-bit = 1 นั่นหมายความว่า clock-tick ล่าสุดเขาพึ่งทำงานไป ซึ่งมันจึงทำให้เกิด 8 policy นั่นได้แก่
                1. Optimal : policy นี้ไม่มีอยู่จริง เพราะเราสามารถหาค่าในอนาคตได้ แต่เหตุที่ต้องมี policy นี้เพราะว่า เอาไว้เปรียบเทียบหา policy ที่มีค่าใกล้เคียงกับเจ้าตัวนี้มากที่สุด โดยหลักการทำงาน คือ เราจะเลือกตัวที่มีการเข้าถึงช้าที่สุดเลย โดยตัวนั้นแหละจะถูก replece เมื่อเกิด page fault ดูตัวอย่างการคิดหน้า(85-88)
                2. LRU(Least Recently Use) : คือการเลือก page ที่มีการใช้น้อยที่สุดให้เอาออกไปด้วยการ replace หน้า(103)
                3. FIFO(First In First Out) : หลักการตัวนี้คือ ตัวไหนเข้ามาตัวแรกตัวนั้นโดน replace ฉะนั้น policy นี้เลยยังไม่ค่อยดีเท่าไรเพราะมันขัดต่อหลักการที่ว่า page ล่าสุดที่ถูกเรียกใช้งานจะต้องคงอยู่ แต่ FIFO บอกว่า เรื่องของมึง อิอิ จริงๆน้องก็ไม่ได้ใจร้ายขนาดนั้นหรอก หน้า(94)
                4. Clock(Second Chance) : อันนี้เกิดจาก FIFO คือ เราจะดูตามเข็มนาฬิกาว่า ตัวไหนที่มี R-bit เป็น 0 และเก่าสุด ถ้าตรงตามเงื่อนไขนี้ให้ replace ได้เลย และทุกๆ r-bit ที่เข็มนาฬิกาเดินผ่านมา เราจะ set r-bit ให้เท่ากับ 0 ด้วย ยกเว้นตัวใหม่ที่พึ่งถูกแทนที่มานะ ที่จะมีค่า r-bit = 1 หน้า(96-98)
                5. NRU(Not Least Recently Used) : คือการพิจารณาการ replace ของ page โดยสังเกตลำดับการเอาออกจากมากไปน้อยดังนี้
                    - Not Refference, Not Modified
                    - Not Refference, Modified
                    - Refference, Not Modified
                    - Refference, Modified
                6. NFU(Not Frequently Used) : คือการที่ในที่ page table จะต้องมีการเก็บค่า counter ไว้ด้วยว่า page นี้ถูกเข้าถึงกี่รอบแล้ว ยิ่งรอบเยอะยิ่งไม่โดนเอาออก แต่มันมีข้อเสียตรงที่ ในอดีตอะตัวนี้เคยถูกเข้าถึงบ่อย แต่ตอนนี้ตัวนี้ไม่ได้เข้าถึงแบบมานานแล้ว ซึ่งยังไม่มีใครแซง counter เขาได้เลย สลับมาที่ page ที่กำลังจะได้ถูกใช้บ่อยขึ้นแต่เพราะว่าพึ่งเริ่มใช้ไง counter มันเลยน้อยซึ่งส่งผลให้น้องโดนเอาออกบ่อย ซึ่งวิธีนี้ก็ยังไม่ค่อยดี
                7. Aging Algorithm : คือการเก็บค่า R-bit ว่าในช่วงระยะเวลาที่ผ่านมา R-bit ถูกเข้าถึงเยอะแค่ไหน ถ้ามีเลขหนึ่งฝั่งซ้ายเยอะก็แสดงว่า page นี้สำคัญยังไม่ต้อง replace แต่ถ้า R-bit ไปกองกันอยู่ฝั่งขวาแล้ว ก็แสดงว่า replace ได้เลย ดูหน้า(97)
                8. Working set : คือเรากำหนดค่า K และค่า T 
                    K : K เรามีไว้กำหนดความเป็น working set 
                    T(Tao Value) : คือช่วงที่ กำหนดระยะความเป็น working set ว่าในช่วงเวลาที่ผ่านมานั้น page ไหนถูกเข้าถึงบ้าง ดูหน้า(108)
    > คลิปที่สี่(ไฮไลต์สีแดงแบบแดงสัสอะ หัวร้อนและอีเหี้ยเยอะชิบหาย)
            - Algorithms Belady's Anomaly = M(m, r) ต้องเป็น sub-set ของ M(m+1, r)
                m = จำนวน frames อะเอาง่ายๆ
                r = index
                เขาบอกว่า ใน index ที่เท่ากัน ต่อให้จะเป็น 3 หรือ 4 frames ยังไงตัวเลขก็ต้องเป็น sub-set กัน ซึ่ง FIFO ทำไม่ได้ แต่ LRU Stack ทำได้
            - Local Vs Global Allocation Policies : เราจะรู้ได้อย่างไรว่าเราควรให้ process นี้มี page และ frame อย่างละเท่าไร ถ้าบอกว่าให้ทุกคนเท่ากันหมด ก็ไม่ได้อีกเพราะว่าแต่ละคนมีขนาดพื้นที่และความจำเป็นที่ต่างกัน ฉะนั้นเราเลยมี 3 ทางเลือก
                1. Original Configuration : การกำหนดค่าของ process ปกติที่มีความแตกต่างกันตามความจำเป็น
                2. Local Allocation : อันนี้หมายความว่า จะดู age ที่มีค่าน้อยสุดหรือว่าไม่ได้ใช้นานแล้วอะ เอาออกถ้าเกิดการ replace
                3. Global Allocation : คือการดู age เหมือนกันแต่อันนี้ดูทุกๆ age เลยแล้วหาว่า age ไหนน้อยสุด จากนั้นทำการ replace ไม่สนว่าจะอยู่ในพื้นที่ของ process ที่ตนเองใช้อยู่หรือไม่
            ซึ่งผลเสียงที่ตามมาคือ พอเราใช้ Global อะ แล้วน้อนเขาไม่แย่ง page คนอื่นๆ ทำให้เขาได้ใช้น้อยลงแล้วใครมันจะชอบอะ มันเลยเกิดการกำหนด Higher and Lower Bound เพื่อเป็นการกำหนดของเขตที่ process จะได้ครอบครอง page เยอะเกินไป หรือว่า process นั้นจะเกิด page fault เยอะเกินไป มันคือการหาความสมดุลอะคับ
            - Load Control : น้องคือตัวโหลด หรือตัวกำกับ Degree of Multiprogramming ว่าจะเยอะแค่ไหน ซึ่งในทุกๆระบบเมื่อมี process ที่เยอะอัตราการโหลดหรือการเคลื่อนย้ายอะไรต่างๆ ก็เยอะขึ้นด้วย และสิ่งที่เราเน้นที่สุดในบทนี้คือ การ swap in - out ของ page ที่ถูก replace ซึ่งมันจะทำให้ใช้เวลาที่สูงมาก เพราะมันต้องรอ I/O
                ซึ่งปัญหาของมัน คือ 
                    - Thrash : คือการที่ระบบเกิดสภาวะ page fault เยอะเกินไปจนทำให้ os ต้องเอาแต่คอยจัดการการ swap in and swap out จนไม่ได้ทำเหี้ยอะไรเลย ซึ่งการเกิด Thrashing นั้นสามารถเกิดขึ้นได้กับทุกๆระบบ ไม่ว่าระบบนั้นจะดีแค่ไหน
                    - PFF(Page Fault Frequency) : คือการมันคือ ปัญหาของ Local Vs Global Allocation Policies อันนี้แหละ คือไม่มีใครอยากให้ตัวเองใช้พื้นที่ที่น้อยอะ เข้าใจเนอะ
                วิธีแก้ คือ 
                    - ลดจำนวน process ให้น้อยลงหรืออีกอย่างนึง ก็คือ การลดจำนวน Degree of Multiprogramming นั่นเอง เพราะว่าการทำเช่นนี้ จะช่วยลดหลายอย่างมาก และยังเป็นการเพิ่ม page และ frames ได้อีกด้วย
    > คลิปที่ห้าจบแล้วววววววววววววววว(ไฮไลต์สีส้มจ้าาาา)
        คือ คลิปนี้อยากจะบอกก่อนว่า เทคนิคการจัดการของ Virtual Memory อะมี 2 ประเภท คือ 
                    1. Paging ซึ่งมันคือสิ่งที่เราพิมพ์มาข้างบนนั่นแหละ
                    2. Segmentation 
                ซึ่งเราจะขอกล่าวต่อจาก Paging ก่อนนะ
            - ขนาดของ Page size ?
                ขนาดของ page size นั้นส่งผลต่อ page table มากถ้าหาก page size มีขนาดเล็กนั่นเท่ากับว่า จะต้องมีหลาย page size มากขึ้นทำให้ตารางใหญ่ขึ้นและการหาหรืออื่นๆก็จะนานขึ้นด้วย แต่ข้อดีของ page size เล็กๆ คือ ลดการเกิด Internal Fragmentation ได้
                แต่ถ้าขนาดของ page size ใหญ่มันก็จะไม่ค่อยดีเพราะว่าถ้า page size ใหญ่ขึ้นก็มีโอกาสทำให้มีการเอาข้อมูลส่วนที่เป็น Locality มาใช้น้อยลงจนในที่สุดก็อาจจะทำให้เกิด page fault ได้ แต่ถ้าขนาดของ page size ใหญ่เท่ากับขนาดของ process ก็จะมีอัตราการเกิด page fault เป็น 0 แต่ก็นั่นแหละมันก็จะมีอันที่ใช้กับไม่ใช้มาอยู่ด้วยไง
            - Fetch Policy : โดยปกติแล้ว Fetch Policy จะมี 2 ประเภท ได้แก่
                1. Demand pagging : เอา pagging ที่มีการใช้จริงๆเข้ามาเท่านั้น คือเอาเข้ามาแบบให้มันครอบคลุม Locality อะ
                2. pre-pagging : ส่วนอันนี้คือ เราแบบเอามาเผื่อรอบหน้าเลยทรงมันคล้าย spartial นะแบบ เอารอบข้างเข้ามารอไว้เลย เพื่อลดการเกิด page fault
            - Degree of Multiprogramming : คือการที่เราพยายามจะ process utilization ให้ได้มากที่สุด แต่ผลลัพธ์ที่ได้ คือ ถ้าหากเรามี Process เยอะแล้วเกิดว่า Locality ของแต่ละ Process เกิดการย้ายกลุ่มซึ่งส่งผลต่อการเกิด page fault ทำให้จำนวนของ process นั้นส่งผลต่อ page fault และจะส่งผลต่อ Thrashing ซึ่งการลดจำนวนของ process มีส่วนช่วยลดการเกิด Thashing ลง
            - แล้วที่เราบอกว่าเราลด process อะมันคือการ suspend process เพื่อลดการเกิด Thashing ลงใช่ไหม แล้วเราจะรู้ได้อย่างไรว่า เราควรจะ suspend process ไหน ?
                - คือเราลด จน. process เพื่อที่จะได้คืนพื้นที่ให้อะ เพราะฉะนั้นการเลือกวิธีใดวิธีนึงก็ต้องเลือกให้สอดคล้องอะ คำตอบก็คือ มี 6 วิธี ได้แก่
                    1. priority ต่ำสุด : แต่ก็แบบไอ้สัสกูอีกแล้วหรอเดี๋ยวก็เกิด Starvation แม่งเลยหนิ
                    2. เลือก process ที่อยู่ในสภาพ page fault เลย
                    3. เลือก process ที่พึ่งเริ่มทำงาน
                    4. เลือก process ที่มี resident set น้อยๆ
            **เพิ่มเติม Resident set และ Working set ต่างกันอย่างไร?**
                Resident set คือ จำนวน หรือ กลุ่มของ page ที่พึ่งมาอยู่บนหน่วยความจำถ้าหากพึ่งเริ่มทำงานอะนะ แต่ถ้าไม่ได้พึ่งเริ่มก็คือ จำนวน page ที่อยู่บนหน่วยความจำนั่นแหละ
                Working set คือ จำนวน หรือ กลุ่มของ page ที่จะทำงานโดยอ้างอิงถึง Locality
                ถ้าหาก Working set มีขนาดน้อยกว่า Resident set หมายความว่า Locality ทั้งหมดอยู่บนหน่วยความจำแล้วเรียบร้อย ฉะนั้นเกิด page fault น้อยแน่นอน
                แต่ถ้าหาก Resident set มีขนาดน้อยกว่า Working set หมายความว่า Locality ไม่ได้อยู่บนหน่วยความจำทั้งหมดก็อาจจะต้องเกิดการ Replace เอาถ้าเกิด page fault
                    5. เลือก process ที่มีขนาดใหญ่เลย ได้ frame เยอะสมใจอยากแน่นอน
                    6. เลือก process ที่แบบโหอห อีกนานเลยกว่าเขาจะทำเสด
            - Cleaning Policy : คือการที่จะมี paging deamon เป็นตัวเช็คด้วย Replacement policy แบบเช็คล่วงหน้าเลยนะว่าแบบ page ไหนมีโอกาสที่จะเกิด page fault ถ้าแบบว่าโอเครเรารู้แล้วว่า page นี้โดนแน่นอน ฉะนั้นเราจะเช็คก่อนว่า page นั้นมี dirty-bit ไหมซึ่งจริงๆมันก็คือ m-bit นั่นแหละต่อจากนั้นเราจะทำการส่ง I/O Request เพื่อทำการเขียนลงดิสถ้าหากมี m-bit แต่ถ้าไม่มีก็ไม่ทำอะไรต่อจากนั้นเมื่อ page นั้นก็เกิด fault ขึ้นมาจริงๆ มันก็ง่ายและ เพราะเรา clean ไปแล้วนั่นเองเขียนลงดิสแล้วเรียบร้อยถ้ามี m-bit ประมาณนี้
            - เมื่อเกิด page fault แล้วต้องทำอะไรบ้าง?
                1. MMU จะส่ง page fault interrupts ไปที่ Cpu ต่อจากนั้น OS จะเริ่มทำงาน
                2. ทำการ save ทุกอย่างของ process นั้นไว้ต่อจากนั้นย้ายจาก running -> block
                3. Os จะหาว่า Address ใน Table ไหนที่พาล่มแล้วต่อจากนั้น Os จะไปเอา Virtual page จาก Disk เข้ามา
                4. Os เช็คว่า Addr นี้ถูกไหม ต่อจากนั้นจะทำการหา frame ที่ว่าง ถ้าเจอ frame ที่ว่างก็เอา Virtual page เข้ามาได้เลย
                5. แต่ถ้าเป็น dirty ก็ต้องทำอย่างที่พิมพ์ไปด้านบนเลย 
                6. จากนั้น OS ก็ทำการ Replace
                7. Update page table
                8. ถ้าเกิด page fault ในขณะที่กำลังทำ instruction หลังจากแก้ page fault แล้ว จะมีการถอยหลังเพื่อกลับไปทำ instruction นั้นอีกรอบ เขาเรียก "Instruction Backup" แต่ว่าจะเกิดขึ้นตอน exe นะไม่ใช่ว่า แก้เสดแล้วทำเลยไม่ใช่ๆ ต้องรอ cpu ด้วย
                9. รอรอบในการกลับมา excute อีกรอบ
                10. คืนค่าสถานะที่เก็บเอาไว้ตั้งแต่ขั้นตอนที่ 2
                11. โปรแกรมทำงานต่อจากที่ทำไว้ครั้งก่อนที่จะเกิด page fault
            - เทคนิคที่ 2 ของการทำ Virtual Mem คือ การใช้ Segmentation
                - ข้อดีของ Segmentation คือ สามารถทำให้ room of growth ของ process นั้นทำได้อย่างเต็มที่ และเรายังสามารถกำหนด protection หรือรายละเอียดต่างๆได้อีกด้วยในแต่ละ segment ที่เราทำ
                - ข้อเสียคือ โปรแกรมเมอร์ต้องเป็นคนกำหนดเอง
                ส่วนหลักการทำงานทุกอย่างไม่ว่าจะเป็น Address Translation หรือจะเป็น TLB ดูได้จากหน้า(70-71) ได้เลยวิธีแทบเหมือนกันเลยมันจะประมาณนี้
                CPU-VirtualAddr-> TLB Segment -> Seg Table-> page table-> physical addrees memory เพื่อเอา content จบ
```